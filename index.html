<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Simple Playlist Extractor — Emerald</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .row-hover:hover{background:rgba(0,0,0,0.03);} 
    .drop-active{ border-color: #059669 !important; background: rgba(5,150,105,0.06); }
  </style>
</head>
<body class="bg-gray-50 text-gray-900">
  <div class="max-w-4xl mx-auto p-6 space-y-6">
    <section class="bg-white rounded-2xl shadow overflow-hidden">
      <!-- Emerald accent strip (24px) -->
      <div class="h-6 bg-emerald-700"></div>

      <!-- Card content -->
      <div class="p-6 space-y-4">
        <h1 class="text-xl font-bold">Simple Playlist Extractor</h1>

        <!-- Status / Error -->
        <div id="status" class="hidden rounded-lg border border-blue-300 bg-blue-50 text-blue-800 p-3 text-sm"></div>
        <div id="error" class="hidden rounded-lg border border-red-300 bg-red-50 text-red-800 p-3 text-sm"></div>

        <!-- Controls -->
        <div class="grid md:grid-cols-2 gap-4">
          <!-- File picker + actions (centered stacked, dotted gray border, drag & drop) -->
          <div id="dropZone" class="rounded-lg border-2 border-dotted border-gray-300 flex flex-col items-center justify-center gap-3 p-8 text-center transition-colors">
            <p class="text-lg text-gray-800">Drop .jwlplaylist / .jwlibrary here</p>
            <span class="text-sm text-gray-500">or</span>
            <label class="inline-block">
              <input type="file" id="fileInput" accept=".jwlplaylist,.jwlibrary" class="hidden">
              <span class="px-4 py-2 rounded-lg bg-emerald-600 text-white cursor-pointer hover:bg-emerald-700">Choose file…</span>
            </label>
            <p class="text-xs text-gray-600" id="fileName">File: —</p>
            <div class="flex gap-2">
              <button id="extractBtn" type="button" class="px-4 py-2 rounded-lg bg-emerald-700 text-white hover:bg-emerald-800 disabled:opacity-50" disabled>Extract</button>
              <button id="smokeTest" type="button" class="px-3 py-2 rounded-lg border border-emerald-600 text-emerald-700 bg-white hover:bg-emerald-50">Self‑test</button>
            </div>
          </div>

          <!-- View & Filter options -->
          <div class="rounded-xl p-4 border space-y-3">
            <label class="inline-flex items-center gap-2 text-sm">
              <input id="toggleChecklist" type="checkbox" class="h-4 w-4 rounded border-gray-300">
              <span>Show as checklist</span>
            </label>

            <!-- Include marker labels toggle (off by default) -->
            <label class="block inline-flex items-center gap-2 text-sm">
              <input id="toggleMarkers" type="checkbox" class="h-4 w-4 rounded border-gray-300">
              <span>Include marker labels (PlaylistItemMarker.Label)</span>
            </label>

            <div class="text-sm">
              <div class="font-medium mb-1">Show:</div>
              <div class="flex flex-wrap gap-3">
                <label class="inline-flex items-center gap-2">
                  <input type="radio" name="showMode" value="all" class="h-4 w-4" checked> <span>All</span>
                </label>
                <label class="inline-flex items-center gap-2">
                  <input type="radio" name="showMode" value="filtered" class="h-4 w-4"> <span>Filtered</span>
                </label>
                <label class="inline-flex items-center gap-2">
                  <input type="radio" name="showMode" value="custom" class="h-4 w-4"> <span>Custom</span>
                </label>
              </div>
            </div>

            <!-- Custom controls -->
            <div id="customControls" class="space-y-2 hidden">
              <div class="text-xs text-gray-600">Enter comma‑separated values.</div>
              <div class="grid grid-cols-1 gap-2">
                <label class="text-sm">
                  <span class="block mb-1">Prefix (starts with):</span>
                  <input id="customPrefixes" class="w-full rounded-md border p-2">
                </label>
                <label class="text-sm">
                  <span class="block mb-1">Exact (match exactly):</span>
                  <input id="customExacts" class="w-full rounded-md border p-2">
                </label>
              </div>
            </div>
          </div>
        </div>

        <!-- Diagnostics summary row (right aligned) with standalone big copy icon -->
        <div class="w-full flex justify-end items-center gap-2">
          <div id="diagTop" class="inline-flex items-center gap-2 text-xs bg-gray-50 border border-gray-200 rounded-full px-3 py-1 shadow-sm"></div>
          <button id="copyTable" class="inline-flex items-center justify-center h-8 w-8 rounded-full border border-gray-200 bg-white hover:bg-gray-50 active:bg-gray-100 shadow-sm"
                  title="Copy results" aria-label="Copy results">
            <svg id="copyTableIcon" xmlns="http://www.w3.org/2000/svg" class="h-4.5 w-4.5 text-gray-700" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8">
              <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
              <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
            </svg>
          </button>
        </div>

        <!-- Extracted Data Display -->
        <div id="checklist" class="space-y-2 mt-2"></div>
      </div>
    </section>
  </div>

  <!-- JSZip + sql.js -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sql.js@1.9.0/dist/sql-wasm.js"></script>

<script>
const $ = (sel) => document.querySelector(sel);
const statusEl = $("#status");
const errorEl = $("#error");
const diagTopEl = $("#diagTop");
const copyTableBtn = $("#copyTable");
let copyTableIcon = $("#copyTableIcon");
function showStatus(msg){ statusEl.textContent = msg || ""; statusEl.classList.toggle("hidden", !msg); }
function showError(msg){ errorEl.textContent = msg || ""; errorEl.classList.toggle("hidden", !msg); if (msg) showStatus(""); }
function showDiagTopHTML(count, sources){
  const text = `Detected labels: ${count} — Sources → ${sources}`;
  diagTopEl.innerHTML = `
    <svg xmlns="http://www.w3.org/2000/svg" class="h-3.5 w-3.5 text-emerald-700" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
      <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm.75-11.75a.75.75 0 10-1.5 0v4.25a.75.75 0 001.5 0V6.25zM10 14a1 1 0 100-2 1 1 0 000 2z" clip-rule="evenodd" />
    </svg>
    <span class="font-medium text-gray-700">${text}</span>
  `;
}

// Elements
const dropZone = $("#dropZone");
const fileInput = $("#fileInput");
const fileName = $("#fileName");
const extractBtn = $("#extractBtn");
const smokeBtn = $("#smokeTest");
const checklistEl = $("#checklist");
const toggleChecklist = $("#toggleChecklist");
const toggleMarkers = $("#toggleMarkers");
const customControls = $("#customControls");
const customPrefixes = $("#customPrefixes");
const customExacts = $("#customExacts");
const showModeInputs = document.getElementsByName("showMode");

let pickedFile = null;
let SQL_INIT_OK = false;
let latestRaw = { base: [], markers: [], diagBase: '', diagMarkers: '', diagFallback: '' };
let latestData = []; // flattened + filtered view

// Persistence helpers
const LS = {
  get(k, fallback=null){ try { const v = localStorage.getItem(k); return v===null? fallback : JSON.parse(v); } catch(_){ return fallback; } },
  set(k, v){ try { localStorage.setItem(k, JSON.stringify(v)); } catch(_){} }
};

const DEFAULT_EXCLUDE_PREFIXES = ["Title", "Title Page", "Subheading", "Q", "R", "Review"];
const STATE_KEYS = {
  asChecklist: "pe.asChecklist",
  includeMarkers: "pe.includeMarkers",
  showMode: "pe.showMode",
  customPrefixes: "pe.customPrefixes",
  customExacts: "pe.customExacts",
  checks: "pe.checks"
};

// Global error capture
window.addEventListener('error', (e) => showError((e.error && e.error.message) ? e.error.message : (e.message || 'Unexpected error')));
window.addEventListener('unhandledrejection', (e) => showError((e && e.reason && (e.reason.message || e.reason)) || 'Unhandled promise rejection'));

// Init sql.js
(async function initSQL(){
  try {
    showStatus("Loading SQL engine...");
    if (typeof initSqlJs !== 'function') throw new Error('initSqlJs is not available (CDN blocked?)');
    window.SQL = await initSqlJs({ locateFile: f => "https://cdn.jsdelivr.net/npm/sql.js@1.9.0/dist/" + f });
    SQL_INIT_OK = !!window.SQL;
    if (!SQL_INIT_OK) throw new Error("sql.js failed to initialize.");
    showStatus("SQL ready.");
  } catch (err) {
    SQL_INIT_OK = false;
    showError("SQL init error: " + (err && err.message ? err.message : String(err)) + " — The Extract button will not work until this loads.");
  }
})();

// Restore persisted UI state
function restoreUIState(){
  toggleChecklist.checked = !!LS.get(STATE_KEYS.asChecklist, false);
  toggleMarkers.checked = !!LS.get(STATE_KEYS.includeMarkers, false); // default OFF
  const showMode = LS.get(STATE_KEYS.showMode, "all");
  [...showModeInputs].forEach(inp => inp.checked = (inp.value === showMode));
  customPrefixes.value = (LS.get(STATE_KEYS.customPrefixes, "") || "");
  customExacts.value = (LS.get(STATE_KEYS.customExacts, "") || "");
  customControls.classList.toggle("hidden", showMode !== "custom");
}
restoreUIState();

async function loadZipAndDb(file){
  if (!SQL_INIT_OK) throw new Error("SQL engine not ready (check internet connection).");
  showStatus("Reading archive...");
  const zip = await JSZip.loadAsync(file);
  // Try common names, else first .db file
  const tryNames = ["userData.db", "UserData.db", "userdata.db", "jwpub.db", "data.db"];
  let dbEntry = null;
  for (const name of tryNames){
    const f = zip.file(name);
    if (f && f.length) { dbEntry = f[0]; break; }
  }
  if (!dbEntry){
    const anyDb = zip.file(/\.db$/i)[0];
    if (!anyDb) throw new Error("No .db file found inside the archive.");
    dbEntry = anyDb;
  }
  const buf = await dbEntry.async("arraybuffer");
  const db = new SQL.Database(new Uint8Array(buf));
  return db;
}

function tableExists(db, name){
  const res = db.exec(`SELECT name FROM sqlite_master WHERE type='table' AND lower(name)=lower('${name}')`);
  return !!(res[0] && res[0].values && res[0].values.length);
}

// Extract both sources once; show/hide markers via checkbox without re-reading DB
function extractRawLabels(db){
  const base = [];
  const markers = [];
  let diagBase = '';
  let diagMarkers = '';
  let diagFallback = '';

  function addFromQuery(sql, pushTo, tag){
    try{
      const r = db.exec(sql);
      const n = (r[0] && r[0].values) ? r[0].values.length : 0;
      if (n){
        r[0].values.forEach(v => { const t = (v[0]||"").toString().trim(); if (t) pushTo.push(t); });
      }
      return `${tag}: +${n}`;
    }catch(e){
      return `${tag} error: ${(e && e.message) || e}`;
    }
  }

  if (tableExists(db, 'PlaylistItem')){
    diagBase = addFromQuery("SELECT Label FROM PlaylistItem WHERE Label IS NOT NULL", base, 'PlaylistItem.Label');
  }
  if (tableExists(db, 'PlaylistItemMarker')){
    diagMarkers = addFromQuery("SELECT Label FROM PlaylistItemMarker WHERE Label IS NOT NULL", markers, 'PlaylistItemMarker.Label');
  }

  if (base.length === 0 && markers.length === 0){
    // Fallback: any table with a Label column
    const tablesRes = db.exec("SELECT name FROM sqlite_master WHERE type='table'");
    const tables = (tablesRes[0] && tablesRes[0].values) ? tablesRes[0].values.map(v => v[0]) : [];
    const collected = [];
    tables.forEach(t => {
      try{
        const info = db.exec(`PRAGMA table_info('${t}')`);
        const cols = (info[0] && info[0].values) ? info[0].values.map(v => v[1]) : [];
        if (cols.map(c => (c||"").toLowerCase()).includes("label")){
          const tag = `${t}.Label`;
          const note = addFromQuery(`SELECT Label FROM '${t}' WHERE Label IS NOT NULL`, collected, tag);
          diagFallback = diagFallback ? (diagFallback + ' | ' + note) : note;
        }
      }catch(_){/* ignore */}
    });
    // Treat fallback as base
    base.push(...collected);
  }

  return { base, markers, diagBase, diagMarkers, diagFallback };
}

function dedupePreserveOrder(arr){
  const seen = new Set();
  const out = [];
  arr.forEach(l => { const k = (l||'').toLowerCase(); if (l && !seen.has(k)){ seen.add(k); out.push(l); } });
  return out;
}

function getShowMode(){
  const sel = [...showModeInputs].find(i => i.checked);
  return sel ? sel.value : "all";
}

function parseCSV(str){
  return (str || "")
    .split(",")
    .map(s => s.trim())
    .filter(Boolean);
}

function applyFilters(labels){
  const mode = getShowMode();
  if (mode === "all") return labels;

  if (mode === "filtered"){
    const excluded = DEFAULT_EXCLUDE_PREFIXES.map(p => p.toLowerCase());
    return labels.filter(lbl => {
      const l = lbl.toLowerCase();
      return !excluded.some(p => l.startsWith(p.toLowerCase()));
    });
  }

  const prefixes = parseCSV(customPrefixes.value).map(p => p.toLowerCase());
  const exacts = parseCSV(customExacts.value).map(e => e.toLowerCase());

  if (prefixes.length === 0 && exacts.length === 0) return labels;

  return labels.filter(lbl => {
    const l = lbl.toLowerCase();
    const prefixMatch = prefixes.some(p => l.startsWith(p));
    const exactMatch = exacts.includes(l);
    return prefixMatch || exactMatch;
  });
}

function updateDiagnosticsView(){
  const includeMarkers = !!toggleMarkers.checked;
  const count = latestData.length;
  let sources = latestRaw.diagBase || 'No sources';
  if (includeMarkers && latestRaw.diagMarkers){
    sources = sources ? (sources + ' | ' + latestRaw.diagMarkers) : latestRaw.diagMarkers;
  }
  if (!sources && latestRaw.diagFallback){
    sources = latestRaw.diagFallback;
  }
  showDiagTopHTML(count, sources);
}

function getVisibleLabels(){
  const includeMarkers = !!toggleMarkers.checked;
  const joined = includeMarkers ? [...latestRaw.base, ...latestRaw.markers] : [...latestRaw.base];
  return dedupePreserveOrder(joined);
}

function getCopyItems(){
  const isChecklist = !!toggleChecklist.checked;
  const items = [];
  if (isChecklist){
    // copy only checked items
    const rows = checklistEl.querySelectorAll('tr');
    rows.forEach(row => {
      const cb = row.querySelector('input[type="checkbox"]');
      const span = row.querySelector('td span');
      if (cb && cb.checked && span){
        const txt = span.textContent.trim();
        if (txt) items.push(txt);
      }
    });
  } else {
    // copy all visible rows
    const tds = checklistEl.querySelectorAll('td');
    tds.forEach(td => {
      const txt = td.textContent.trim();
      if (txt) items.push(txt);
    });
  }
  return items;
}

function getChecks(){ return LS.get(STATE_KEYS.checks, {}); }
function setChecks(obj){ LS.set(STATE_KEYS.checks, obj || {}); }

function renderAllData(){
  const asChecklist = !!toggleChecklist.checked;
  checklistEl.innerHTML = '';

  let labels = getVisibleLabels()
    .map(txt => (typeof txt === 'string') ? txt.trim() : '')
    .filter(txt => txt.length > 0);

  labels = applyFilters(labels);
  latestData = labels.map(l => ({label: l}));

  if (labels.length === 0){
    const empty = document.createElement('div');
    empty.className = "text-sm text-gray-500";
    empty.textContent = "No labels found.";
    checklistEl.appendChild(empty);
    updateDiagnosticsView();
    return;
  }

  const table = document.createElement('table');
  table.className = "w-1/2 border border-emerald-600 rounded-lg overflow-hidden text-sm";

  if (!asChecklist){
    labels.forEach((txt, idx) => {
      const row = document.createElement('tr');
      row.className = idx % 2 === 0 ? "bg-gray-50" : "bg-white";

      const cell = document.createElement('td');
      cell.className = "px-3 py-2 border-b border-gray-200";
      cell.textContent = txt;

      row.appendChild(cell);
      table.appendChild(row);
    });
    checklistEl.appendChild(table);
    updateDiagnosticsView();
    return;
  }

  const checks = getChecks();
  labels.forEach((txt, idx) => {
    const row = document.createElement('tr');
    row.className = idx % 2 === 0 ? "bg-gray-50" : "bg-white";

    const cell = document.createElement('td');
    cell.className = "px-3 py-2 border-b border-gray-200 flex items-center";

    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.className = "mr-2";
    cb.checked = !!checks[txt];

    cb.addEventListener('change', () => {
      const updated = getChecks();
      if (cb.checked) updated[txt] = true;
      else delete updated[txt];
      setChecks(updated);
    });

    cell.appendChild(cb);
    const span = document.createElement('span');
    span.textContent = txt;
    cell.appendChild(span);

    row.appendChild(cell);
    table.appendChild(row);
  });
  checklistEl.appendChild(table);
  updateDiagnosticsView();
}

// Extract action
async function doExtract(){
  try {
    showError(""); showDiagTopHTML(0, ""); showStatus("Opening package...");
    if (!pickedFile){ showError("No file selected — choose or drop a .jwlplaylist / .jwlibrary first."); return; }
    if (!SQL_INIT_OK){ showError("SQL engine not ready — reload the page or check network to the CDN."); return; }
    extractBtn.disabled = true; extractBtn.textContent = "Extracting…";

    const db = await loadZipAndDb(pickedFile);
    latestRaw = extractRawLabels(db);

    renderAllData();
    const total = latestData.length;
    showStatus(total ? "Done. Data extracted." : "Done. No labels found.");
  } catch (err) {
    console.error(err);
    showError((err && err.message ? err.message : String(err)) + " — See console for details.");
  } finally {
    extractBtn.disabled = false; extractBtn.textContent = "Extract";
  }
}

// File input + drag & drop handling
fileInput.addEventListener("change", async (e) => {
  const f = e.target.files && e.target.files[0];
  if (f){
    pickedFile = f;
    fileName.textContent = "File: " + f.name + " (" + (f.size/1024).toFixed(1) + " KB)";
    extractBtn.disabled = false;
  }
});

["dragenter","dragover"].forEach(evt => {
  dropZone.addEventListener(evt, (e) => {
    e.preventDefault(); e.stopPropagation();
    dropZone.classList.add("drop-active");
  });
});
["dragleave","drop"].forEach(evt => {
  dropZone.addEventListener(evt, (e) => {
    e.preventDefault(); e.stopPropagation();
    dropZone.classList.remove("drop-active");
  });
});

dropZone.addEventListener("drop", (e) => {
  const dt = e.dataTransfer;
  if (!dt || !dt.files || dt.files.length === 0) return;
  const f = dt.files[0];
  const ok = /\.jwlplaylist$|\.jwlibrary$/i.test(f.name);
  if (!ok){
    showError("Unsupported file type. Please drop a .jwlplaylist or .jwlibrary file.");
    return;
  }
  pickedFile = f;
  fileName.textContent = "File: " + f.name + " (" + (f.size/1024).toFixed(1) + " KB)";
  extractBtn.disabled = false;
});

// Self-test (verifies button wiring & SQL availability without a file)
smokeBtn.addEventListener('click', async () => {
  try{
    if (!SQL_INIT_OK){ showError('SQL engine not ready — cannot run self-test.'); return; }
    const db = new SQL.Database();
    db.run("CREATE TABLE PlaylistItem (Label TEXT); INSERT INTO PlaylistItem VALUES ('Opening song'),('Living as Christians'),('Closing song');");
    latestRaw = extractRawLabels(db);
    renderAllData();
    showStatus('Self-test populated 3 sample labels.');
  }catch(e){
    console.error(e);
    showError('Self-test failed: ' + (e && e.message ? e.message : e));
  }
});

// Copy table results handler
copyTableBtn.addEventListener('click', async () => {
  try{
    const items = getCopyItems();
    if (!items.length){ showError("Nothing to copy — no matching items."); return; }
    await navigator.clipboard.writeText(items.join('\n'));
    // visual feedback
    const newIcon = document.createElement('svg');
    newIcon.setAttribute('id','copyTableIcon');
    newIcon.setAttribute('xmlns','http://www.w3.org/2000/svg');
    newIcon.setAttribute('class','h-4.5 w-4.5 text-emerald-700');
    newIcon.setAttribute('viewBox','0 0 24 24');
    newIcon.setAttribute('fill','none');
    newIcon.setAttribute('stroke','currentColor');
    newIcon.setAttribute('stroke-width','2');
    newIcon.innerHTML = '<path d="M20 6L9 17l-5-5" stroke-linecap="round" stroke-linejoin="round"></path>';
    copyTableIcon.replaceWith(newIcon);
    copyTableIcon = newIcon;
    setTimeout(() => {
      const backIcon = document.createElement('svg');
      backIcon.setAttribute('id','copyTableIcon');
      backIcon.setAttribute('xmlns','http://www.w3.org/2000/svg');
      backIcon.setAttribute('class','h-4.5 w-4.5 text-gray-700');
      backIcon.setAttribute('viewBox','0 0 24 24');
      backIcon.setAttribute('fill','none');
      backIcon.setAttribute('stroke','currentColor');
      backIcon.setAttribute('stroke-width','1.8');
      backIcon.innerHTML = '<rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>';
      copyTableIcon.replaceWith(backIcon);
      copyTableIcon = backIcon;
    }, 1200);
  }catch(e){
    showError("Copy failed: " + (e && e.message ? e.message : e));
  }
});

// Option toggles
toggleChecklist.addEventListener('change', () => {
  LS.set(STATE_KEYS.asChecklist, !!toggleChecklist.checked);
  renderAllData();
});

toggleMarkers.addEventListener('change', () => {
  LS.set(STATE_KEYS.includeMarkers, !!toggleMarkers.checked);
  renderAllData();
});

[...showModeInputs].forEach(inp => {
  inp.addEventListener('change', () => {
    LS.set(STATE_KEYS.showMode, inp.value);
    customControls.classList.toggle("hidden", inp.value !== "custom");
    renderAllData();
  });
});

[customPrefixes, customExacts].forEach(inp => {
  inp.addEventListener('input', () => {
    LS.set(STATE_KEYS.customPrefixes, customPrefixes.value || "");
    LS.set(STATE_KEYS.customExacts, customExacts.value || "");
    renderAllData();
  });
});
</script>
</body>
</html>
